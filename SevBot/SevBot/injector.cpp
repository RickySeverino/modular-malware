#include "pch.h"
#include "injector.h"
#include <TlHelp32.h>
#include <io.h>

// acquire debug priviledges on the process used to inject the dll
bool GrantDebugPriv() 
{
	TOKEN_PRIVILEGES priv = { 0 };
	HANDLE hToken = NULL;
	bool success = false;

	if (OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken))
	{
		priv.PrivilegeCount = 1;
		priv.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

		if (LookupPrivilegeValue(NULL, SE_DEBUG_NAME, &priv.Privileges[0].Luid))
		{
			success = AdjustTokenPrivileges(hToken, FALSE, &priv, 0, NULL, NULL);
		}
		CloseHandle(hToken);
	}
	return success;
}

// find target process in list of running processes
bool FindProcessbyName(std::string processName, DWORD &_dwProcessID) 
{
	std::wstring szTempName = std::wstring(processName.begin(), processName.end());
	const wchar_t* wszName = szTempName.c_str();

	HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
	PROCESSENTRY32 procEntry;
	procEntry.dwSize = sizeof(procEntry);

	do {
		if (!wcscmp(procEntry.szExeFile, wszName))
		{
			CloseHandle(hSnapshot);
			_dwProcessID = procEntry.th32ProcessID;
			return true;
		}
	} while (Process32Next(hSnapshot, &procEntry)); // traverse through the list of processes in the snapshot

	return false;
}

bool Inject(std::string processName, std::string dllPath)
{
//	if (!GrantDebugPriv()) return false;

	DWORD dwProcessID, dwMemSize;
	HANDLE hProcess;
	LPVOID lpRemoteMemory, lpLoadLibrary;
	char szPath[MAX_PATH];

	// check to see if target process is running
	if (!FindProcessbyName(processName, dwProcessID)) return false;

	// check to see if dll fle exists
	GetFullPathNameA(dllPath.c_str(), MAX_PATH, szPath, NULL);

	if (_access(szPath, 0) != 0) return false;

	dwMemSize = (DWORD)strlen(szPath) + 1;

	// attach to the target process
	hProcess = OpenProcess(PROCESS_VM_OPERATION | PROCESS_VM_READ | PROCESS_VM_WRITE | PROCESS_CREATE_THREAD, FALSE, dwProcessID);

	if (hProcess == NULL) return false;

	// wait for process to be idle
	WaitForInputIdle(hProcess, INFINITE);

	// allocate memory within the target processs
	lpRemoteMemory = VirtualAllocEx(hProcess, NULL, dwMemSize, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);

	if (lpRemoteMemory == NULL) return false;

	// copy the dll path into the target process' memory
	BOOL bStatus = WriteProcessMemory(hProcess, lpRemoteMemory, (LPCVOID)szPath, dwMemSize, NULL);

	if (bStatus == 0) return false;

	// get handle for kernel32 dll LoadLibrary call
	HMODULE hKernel32 = GetModuleHandle(L"kernel32.dll");

	if (hKernel32 == NULL) return false;

	lpLoadLibrary = GetProcAddress(hKernel32, "LoadLibraryA");

	if (lpLoadLibrary == NULL) return false;

	// instruct the target process to execure the dll
	HANDLE hRemoteThread = CreateRemoteThread(hProcess, NULL, NULL, (LPTHREAD_START_ROUTINE)lpLoadLibrary, lpRemoteMemory, NULL, NULL);

	if (hRemoteThread == NULL) return false;

	// wait for the dll to finish executing
	WaitForSingleObject(hRemoteThread, INFINITE);

	if (hProcess && lpRemoteMemory)
	{
		VirtualFreeEx(hProcess, (LPVOID)lpRemoteMemory, 0, MEM_RELEASE);
		CloseHandle(hProcess);
		return true;
	}
	else 
		return false;
}